<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Golf-Tool — Zufall, Optionen & Scoring</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; --accent:#0a84ff}
  body{margin:0;padding:12px;background:#f6f7fb;color:#111}
  header{display:flex;align-items:center;gap:12px}
  h1{font-size:18px;margin:0}
  .card{background:#fff;border-radius:10px;padding:12px;margin:10px 0;box-shadow:0 1px 3px rgba(0,0,0,.08)}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{padding:10px;border-radius:8px;background:var(--accent);color:#fff;border:0;font-weight:600}
  button.secondary{background:#eee;color:#111}
  .big{font-size:20px;padding:16px}
  .players{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
  .player{border:1px solid #eee;padding:8px;border-radius:8px}
  label{font-size:13px;color:#444}
  input[type=text]{width:100%;padding:8px;margin:6px 0;border-radius:6px;border:1px solid #ddd}
  select{padding:8px;border-radius:6px;border:1px solid #ddd}
  .opt-list{display:flex;flex-direction:column;gap:6px}
  .small{font-size:13px;padding:6px}
  .muted{color:#666;font-size:13px}
  .score{font-weight:800;font-size:18px}
  footer{margin-top:14px;text-align:center;color:#666;font-size:13px}
  .chip{background:#efefef;padding:6px;border-radius:999px;display:inline-block;margin:4px 6px 4px 0}
  .options-editor{display:grid;grid-template-columns:1fr 80px 80px;gap:6px}
  .hidden{display:none}
  @media (max-width:420px){.players{grid-template-columns:1fr}}
</style>
</head>
<body>
<div id="app">
  <header><h1>Golf-Tool (Zufall & Scoring)</h1></header>

  <!-- SETUP STEP 1: Spieleranzahl + Modus -->
  <div id="setupStep1" class="card">
    <div class="row">
      <div>
        <label><strong>Spieleranzahl</strong></label>
        <select id="numPlayersSelect">
          <option value="2">2 Spieler</option>
          <option value="3">3 Spieler</option>
          <option value="4" selected>4 Spieler</option>
        </select>
      </div>
      <div>
        <label><strong>Modus</strong></label><br>
        <select id="modeSelect">
          <option value="einzel">Einzel</option>
          <option value="team">Team (Paare: 1+2 vs 3+4)</option>
        </select>
      </div>
    </div>
    <div style="margin-top:10px">
      <button id="toNamesBtn">Weiter: Namen eingeben</button>
      <button class="secondary" id="loadBtn1">Gespeicherten Stand laden</button>
    </div>
    <p class="muted">Hinweis: Wenn du Team-Modus mit 3 Spielern wählst, wird automatisch Einzelmodus gesetzt.</p>
  </div>

  <!-- SETUP STEP 2: Namenseingabe (dynamisch je nach Auswahl) -->
  <div id="setupStep2" class="card hidden">
    <div><strong>Gib die Spielernamen ein</strong></div>
    <div id="namesContainer" style="margin-top:8px"></div>
    <div style="margin-top:10px">
      <button id="startBtn">Spiel starten</button>
      <button class="secondary" id="backToStep1">Zurück</button>
    </div>
  </div>

  <!-- MAIN UI -->
  <div id="main" class="hidden">
    <div class="row">
      <div style="flex:1" class="card">
        <div><strong>Zufall: Schläger</strong></div>
        <div style="margin:8px 0" id="clubCard" class="big chip">—</div>
        <div class="row">
          <button id="randClubBtn">Schläger zufällig</button>
        </div>
        <hr>
        <div><strong>Zufall: Option (20)</strong></div>
        <div style="margin:8px 0" id="optCard" class="big chip">—</div>
        <div class="row">
          <button id="randOptBtn">Option zufällig wählen</button>
          <button class="secondary" id="assignRandomOpt">Automatisch zuweisen</button>
        </div>
      </div>

      <div style="flex:1" class="card">
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Spieler & Punkte</strong>
          <div>
            <button class="secondary" id="editOptionsBtn">Optionen bearbeiten</button>
            <button id="holeBtn" class="secondary">Bahn erfassen</button>
          </div>
        </div>

        <div id="playersArea" class="players" style="margin-top:10px"></div>

        <div style="margin-top:10px" class="row" >
          <button class="secondary" id="undoHole">Letzte Bahn rückgängig</button>
          <button class="secondary" id="newRound">Neue Runde</button>
        </div>
        <div class="muted" id="roundInfo">Runde: 0 Bahnen</div>
      </div>
    </div>

    <div id="optionsEditor" class="card hidden">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>20 Optionen bearbeiten</strong>
        <div><button id="saveOptions" class="secondary">Speichern</button></div>
      </div>
      <div id="optionsGrid" class="options-editor" style="margin-top:8px"></div>
      <p class="muted">Jede Option hat einen Namen + Punktwert (positiv oder negativ). Eine Option kann immer nur einen Spieler haben.</p>
    </div>

    <div class="card">
      <div><strong>Verlauf (Bahn-Historie)</strong></div>
      <div id="holesList" style="margin-top:8px"></div>
    </div>

    <footer>Lokaler Speicher: dein Spielstand bleibt im Browser erhalten. Zum Home-Bildschirm: Safari → Teilen → „Zum Home-Bildschirm“.</footer>
  </div>
</div>

<script>
(() => {
  // --- Konfiguration / Defaults ---
  const CLUBS = ["Driver","Holz 3","Holz 5","Hybrid","Eisen 4","Eisen 5","Eisen 6","Eisen 7","Eisen 8","Eisen 9","Pitching Wedge","Gap Wedge","Sand Wedge","Putter"];
  const STORAGE_KEY = "golfToolState_v3";
  const defaultOptions = Array.from({length:20}, (_,i) => ({ id:i, label:`Option ${i+1}`, value:0 }));

  // --- State ---
  let state = {
    started: false,
    numPlayers: 4,
    mode: "einzel",
    players: [
      { name:"Spieler 1", score:0 },
      { name:"Spieler 2", score:0 },
      { name:"Spieler 3", score:0 },
      { name:"Spieler 4", score:0 }
    ],
    options: defaultOptions.slice(),
    optionOwner: {}, // optionId -> playerIndex
    holes: [] // { holeNumber, placements, points }
  };

  // small helper
  const $ = sel => document.querySelector(sel);
  const id = s => document.getElementById(s);

  // --- Persistence ---
  function save() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    render();
  }
  function load() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw) {
      try {
        const parsed = JSON.parse(raw);
        // basic migration: ensure required fields exist
        state = Object.assign({}, state, parsed);
        if(!Array.isArray(state.options)) state.options = defaultOptions.slice();
        if(!state.optionOwner) state.optionOwner = {};
        if(!Array.isArray(state.holes)) state.holes = [];
        if(!Array.isArray(state.players)) state.players = state.players || [
          {name:"Spieler 1",score:0},
          {name:"Spieler 2",score:0},
          {name:"Spieler 3",score:0},
          {name:"Spieler 4",score:0}
        ];
      } catch(e) {
        console.error("Ladefehler:", e);
      }
    }
  }
  function resetAll() {
    localStorage.removeItem(STORAGE_KEY);
    state = {
      started: false,
      numPlayers:4,
      mode:"einzel",
      players:[
        {name:"Spieler 1",score:0},{name:"Spieler 2",score:0},{name:"Spieler 3",score:0},{name:"Spieler 4",score:0}
      ],
      options: defaultOptions.slice(),
      optionOwner: {},
      holes: []
    };
    showStep1();
    render();
  }

  // --- Scoring / assign helpers ---
  function recomputeScores() {
    // reset
    for(let i=0;i<state.players.length;i++) state.players[i].score = 0;
    // options
    state.options.forEach(opt => {
      const owner = state.optionOwner[opt.id];
      if(owner != null && state.players[owner]) state.players[owner].score += Number(opt.value) || 0;
    });
    // holes
    state.holes.forEach(h => {
      h.points.forEach((pt, idx) => {
        if(state.players[idx]) state.players[idx].score += pt;
      });
    });
  }

  function assignOptionToPlayer(optId, playerIndex) {
    optId = Number(optId);
    playerIndex = Number(playerIndex);
    // if invalid
    if(isNaN(optId) || isNaN(playerIndex) || !state.players[playerIndex]) return;
    const prev = state.optionOwner[optId];
    if(prev === playerIndex) return; // already there
    // assign (this implicitly removes from previous owner)
    state.optionOwner[optId] = playerIndex;
    save();
  }

  function unassignOption(optId) {
    optId = Number(optId);
    if(state.optionOwner[optId] != null) {
      delete state.optionOwner[optId];
      save();
    }
  }

  // --- UI show/hide ---
  function showStep1() {
    id("setupStep1").classList.remove("hidden");
    id("setupStep2").classList.add("hidden");
    id("main").classList.add("hidden");
  }
  function showStep2() {
    id("setupStep1").classList.add("hidden");
    id("setupStep2").classList.remove("hidden");
    id("main").classList.add("hidden");
  }
  function showMain() {
    id("setupStep1").classList.add("hidden");
    id("setupStep2").classList.add("hidden");
    id("main").classList.remove("hidden");
    render();
  }

  // --- Rendering ---
  function render() {
    recomputeScores();
    renderPlayersArea();
    renderOptionsEditor(); // keep in sync (hidden by default)
    renderHoles();
  }

  function renderPlayersArea() {
    const area = id("playersArea");
    area.innerHTML = "";
    const N = state.numPlayers || 4;
    for(let i=0;i<N;i++){
      const p = state.players[i] || { name:`Spieler ${i+1}`, score:0 };
      const card = document.createElement("div");
      card.className = "player card";
      // build assigned option chips
      const chips = [];
      state.options.forEach(opt => {
        const owner = state.optionOwner[opt.id];
        if(owner === i) {
          chips.push(`<span class="chip">${escapeHtml(opt.label)} (${opt.value>0?'+':''}${opt.value}) <button class="small unassignOptBtn" data-optid="${opt.id}">x</button></span>`);
        }
      });
      // build options select (all options)
      let selHtml = `<select id="selOpt-${i}"><option value="">— wählen —</option>`;
      state.options.forEach(opt => {
        const owner = state.optionOwner[opt.id];
        const ownerNote = owner!=null ? ` (bei ${escapeHtml(state.players[owner]?.name || '–')})` : "";
        selHtml += `<option value="${opt.id}">${escapeHtml(opt.label)} ${ownerNote} [${opt.value>0?'+':''}${opt.value}]</option>`;
      });
      selHtml += `</select>`;

      card.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><input type="text" class="playerNameInput" data-idx="${i}" id="playerName-${i}" value="${escapeHtml(p.name || '')}"></div>
          <div class="score" id="score-${i}">${p.score}</div>
        </div>
        <div class="muted">Optionen:</div>
        <div id="chiparea-${i}">${chips.join('')}</div>
        <div style="margin-top:6px">
          ${selHtml}
          <button class="small assignOptBtn" data-player="${i}">Zuweisen</button>
        </div>
      `;
      area.appendChild(card);
    }
    id("roundInfo").textContent = `Runde: ${state.holes.length} Bahnen`;
  }

  function renderOptionsEditor() {
    const grid = id("optionsGrid");
    // if editor hidden, still update content so it's ready
    grid.innerHTML = "";
    state.options.forEach(opt => {
      const ownerName = state.optionOwner[opt.id] != null ? (state.players[state.optionOwner[opt.id]]?.name || '?') : '';
      const ownerText = ownerName ? `bei ${escapeHtml(ownerName)}` : '';
      const row = document.createElement("div");
      row.style.display = "contents";
      row.innerHTML = `
        <input class="optLabel" data-id="${opt.id}" value="${escapeHtml(opt.label)}">
        <input class="optValue" data-id="${opt.id}" type="text" value="${opt.value}">
        <div class="muted" style="align-self:center">${ownerText}</div>
      `;
      grid.appendChild(row);
    });
  }

  function renderHoles() {
    const list = id("holesList");
    list.innerHTML = "";
    state.holes.forEach(h => {
      const line = document.createElement("div");
      line.className = "chip";
      const parts = [];
      for(let i=0;i<state.numPlayers;i++){
        const name = (state.players[i] && state.players[i].name) ? state.players[i].name : `Spieler ${i+1}`;
        const pt = h.points[i] != null ? h.points[i] : 0;
        parts.push(`${escapeHtml(name)}:${pt>0?'+':''}${pt}`);
      }
      line.textContent = `Bahn ${h.holeNumber}: ${parts.join(' | ')}`;
      list.appendChild(line);
    });
  }

  // --- Events wiring ---
  // STEP1 -> STEP2
  id("toNamesBtn").addEventListener("click", () => {
    const np = Number(id("numPlayersSelect").value);
    let mode = id("modeSelect").value;
    if(mode === "team" && np === 3) {
      alert("Team-Modus mit 3 Spielern ist nicht sinnvoll — setze auf Einzelmodus.");
      mode = "einzel";
      id("modeSelect").value = "einzel";
    }
    // store selection temporarily in state (but don't mark started)
    state.numPlayers = np;
    state.mode = mode;
    // render name inputs according to np
    const container = id("namesContainer");
    container.innerHTML = "";
    for(let i=0;i<np;i++){
      const existing = state.players[i] && state.players[i].name ? state.players[i].name : `Spieler ${i+1}`;
      const block = document.createElement("div");
      block.style.marginBottom = "6px";
      block.innerHTML = `<label>Spieler ${i+1}</label><input type="text" id="nameInput-${i}" placeholder="Name ${i+1}" value="${escapeHtml(existing)}">`;
      container.appendChild(block);
    }
    showStep2();
  });

  // Back to step1
  id("backToStep1").addEventListener("click", () => {
    showStep1();
  });

  // START GAME
  id("startBtn").addEventListener("click", () => {
    const np = Number(state.numPlayers) || 4;
    // read names
    for(let i=0;i<np;i++){
      const el = id(`nameInput-${i}`);
      const v = el ? el.value.trim() : "";
      state.players[i] = state.players[i] || {name:`Spieler ${i+1}`, score:0};
      if(v) state.players[i].name = v;
    }
    // ensure players array length fixed to 4 (so index access safe)
    for(let i=np;i<4;i++){
      state.players[i] = state.players[i] || {name:`Spieler ${i+1}`, score:0};
    }
    // validate team mode
    if(state.mode === "team" && state.numPlayers === 3) {
      alert("Team-Modus mit 3 Spielern ist nicht erlaubt, setze auf Einzelmodus.");
      state.mode = "einzel";
    }
    state.started = true;
    save();
    showMain();
  });

  // Load saved from step1
  id("loadBtn1").addEventListener("click", () => {
    load();
    if(state.started) {
      showMain();
    } else {
      // ensure step1 values match stored state
      id("numPlayersSelect").value = state.numPlayers || 4;
      id("modeSelect").value = state.mode || "einzel";
      showStep1();
    }
  });

  // Random Club
  id("randClubBtn").addEventListener("click", () => {
    id("clubCard").textContent = CLUBS[Math.floor(Math.random()*CLUBS.length)];
  });

  // Random Option display
  let currentOptId = null;
  id("randOptBtn").addEventListener("click", () => {
    const opt = state.options[Math.floor(Math.random()*state.options.length)];
    currentOptId = opt.id;
    id("optCard").textContent = `${opt.label} (${opt.value>0?'+':''}${opt.value})`;
  });

  // Assign displayed option randomly to a player
  id("assignRandomOpt").addEventListener("click", () => {
    if(currentOptId == null) {
      alert("Erst Option wählen (Zufall).");
      return;
    }
    const p = Math.floor(Math.random() * state.numPlayers);
    assignOptionToPlayer(currentOptId, p);
    alert(`Option '${state.options[currentOptId].label}' zugewiesen an ${state.players[p].name}`);
  });

  // Event delegation: assign option from each player's select
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    // assign button
    if(t.classList.contains("assignOptBtn")) {
      const playerIndex = Number(t.dataset.player);
      const sel = id(`selOpt-${playerIndex}`);
      if(!sel) return;
      const val = sel.value;
      if(!val) { alert("Bitte Option wählen."); return; }
      assignOptionToPlayer(val, playerIndex);
      alert(`Option '${state.options[val].label}' zugewiesen an ${state.players[playerIndex].name}`);
      return;
    }
    // unassign button (on chip)
    if(t.classList.contains("unassignOptBtn")) {
      const optId = Number(t.dataset.optid);
      unassignOption(optId);
      return;
    }
  });

  // Edit options toggle
  id("editOptionsBtn").addEventListener("click", () => {
    const ed = id("optionsEditor");
    if(ed.classList.contains("hidden")) {
      renderOptionsEditor();
      ed.classList.remove("hidden");
    } else {
      ed.classList.add("hidden");
    }
  });

  // Save options
  id("saveOptions").addEventListener("click", () => {
    // read inputs
    const labels = Array.from(document.querySelectorAll(".optLabel"));
    const values = Array.from(document.querySelectorAll(".optValue"));
    // map by data-id
    const newOpts = [];
    labels.forEach((lbl) => {
      const idn = Number(lbl.dataset.id);
      const label = lbl.value || `Option ${idn+1}`;
      const valEl = document.querySelector(`.optValue[data-id='${idn}']`);
      const value = valEl ? Number(valEl.value) || 0 : 0;
      newOpts[idn] = { id: idn, label: label, value: value };
    });
    state.options = newOpts.slice(0,20);
    save();
    alert("Optionen gespeichert.");
  });

  // Hole capture
  id("holeBtn").addEventListener("click", () => {
    const defaultHole = (state.holes.length + 1);
    const hnumRaw = prompt("Bahnnummer (1–18)", defaultHole);
    if(hnumRaw === null) return;
    const hnum = Number(hnumRaw);
    if(isNaN(hnum) || hnum < 1 || hnum > 18) { alert("Ungültige Bahnnummer."); return; }

    // Team-mode for 4 players: ask Team A only
    if(state.mode === "team" && state.numPlayers === 4) {
      const teamA = prompt("Platzierung Team A (Spieler 1+2): 1=gewonnen,2=verloren,T=geteilt", "1");
      if(teamA === null) return;
      const teamB = (teamA === "1") ? "2" : (teamA === "2" ? "1" : "T");
      const map = { "1": 1, "2": -1, "T": 0 };
      const ptsA = map[teamA] || 0;
      const ptsB = map[teamB] || 0;
      const points = [ptsA, ptsA, ptsB, ptsB];
      state.holes.push({ holeNumber: hnum, placements: [`TeamA:${teamA}`, `TeamB:${teamB}`], points });
      save();
      return;
    }

    // For other modes (einzel or team with 2 players) ask per player
    const placements = [];
    for(let i=0;i<state.numPlayers;i++){
      const nm = state.players[i] && state.players[i].name ? state.players[i].name : `Spieler ${i+1}`;
      const val = prompt(`Platz für ${nm} (1..${state.numPlayers} oder T für geteilt)`, "1");
      if(val === null) return;
      placements[i] = (String(val).toUpperCase() === "T") ? "T" : Number(val);
    }
    // compute points mapping
    const N = state.numPlayers;
    const map = (N === 4) ? {1:2,2:1,3:-1,4:-2} : (N === 3) ? {1:1,2:0,3:-1} : {1:1,2:-1};
    // detect ties: rankCount
    const rankCount = {};
    placements.forEach(p => { if(p !== "T") rankCount[p] = (rankCount[p] || 0) + 1; });
    const points = [];
    for(let i=0;i<N;i++){
      const p = placements[i];
      if(p === "T") { points[i] = 0; continue; }
      if(rankCount[p] > 1) { points[i] = 0; continue; }
      points[i] = map[p] || 0;
    }

    // If team mode with 2 players, treat points as team points (same effect)
    if(state.mode === "team" && state.numPlayers === 2) {
      // points already represent 1 / -1 mapping for 2 players
      // keep as-is
    }

    state.holes.push({ holeNumber: hnum, placements, points });
    save();
  });

  // Undo last hole
  id("undoHole").addEventListener("click", () => {
    if(state.holes.length === 0) { alert("Keine Bahn vorhanden."); return; }
    if(!confirm("Letzte Bahn wirklich entfernen?")) return;
    state.holes.pop();
    save();
  });

  // New round -> reset scores/options/holes and go to setup step1
  id("newRound").addEventListener("click", () => {
    if(!confirm("Neue Runde: Alle Punkte und Optionen zurücksetzen und neu starten?")) return;
    state.started = false;
    state.holes = [];
    state.optionOwner = {};
    // reset player scores, keep names
    for(let i=0;i<state.players.length;i++) state.players[i].score = 0;
    save();
    showStep1();
  });

  // Name edits in main
  document.addEventListener("input", (ev) => {
    const t = ev.target;
    if(t.classList && t.classList.contains("playerNameInput")) {
      const idx = Number(t.dataset.idx);
      if(!isNaN(idx) && state.players[idx]) {
        state.players[idx].name = t.value;
        save();
      }
    }
  });

  // Load on initial open
  load();
  if(state.started) {
    // ensure UI reflects saved values
    id("numPlayersSelect").value = state.numPlayers;
    id("modeSelect").value = state.mode;
    showMain();
  } else {
    id("numPlayersSelect").value = state.numPlayers || 4;
    id("modeSelect").value = state.mode || "einzel";
    showStep1();
  }

  // util
  function escapeHtml(s) {
    if(!s && s !== 0) return "";
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
  }

})();
</script>
</body>
</html>